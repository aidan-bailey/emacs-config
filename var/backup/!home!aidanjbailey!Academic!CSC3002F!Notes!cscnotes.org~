#+OPTIONS: toc:5
Shitty notes make for a shitty course… made with emacs by Aidan.
DISCLAIMER: These notes are an amalgamation of Josiah’s skinny slides (which are blatantly ripped
from some other university only with a new splash of paint) and various definitions I’ve 
found over the web. I can’t promise these are the exact definitions but they’re the one’s I found 
to be both *accurate and intelligible* and a quick Google search will probably render you the same opinion.
If you still have strong gripes with a particular section, feel free to email me: BLYAID001@myuct.ac.za

* The Internet
A network of networks which allows the World Wide Web a means for existence.

_NUTS AND BOLTS_

 * *Users*

  - Millions of connected devices.

  - /hosts/ as end systems.

  - running /network applications/.

 * *Communication Links*

  - a /medium/ of communication.

  - fibre, copper, radio satellite.

 * *Packet Switches*

  - /routers/ and /switches,/

  - Help forward the /packets/ (chunks of data).

 * *Internet*

  - Interconnected ISPs.
  
 * *Protocols*

  - Control /sending/ and /receiving/ of messages.

  - TCP, IP, HTTP, Skype, 802.11

 * *Internet Standards* 

  - /RFC/: Request for Comments

  - /IETF/: Internet Engineering Task Force

* Protocols

  Protocols are sets of instructions for a communication over a specific medium.

  Specific messages are sent -------> Specific messages are received

  _Define_
 * /Format/ of messages
 * /Order/ of sending and receiving
 * /Actions taken/ on message transmission and receipt
   
** Human Analogy

| Human            | Computer                            |
|------------------+-------------------------------------|
| Hi               | TCP connection request              |
| Hey              | TCP connection response             |
| What's the time? | Get http://www.uct.ac.za/index.html |
| It's 9am         | <file>                              |

** Protocol Layers
     
     Since networks are composed of many different complex pieces, we need to organize 
     our protocols in layers.
     
     | Hosts        | Routers   | Links    | Hardware |
     | Applications | Protocols | Software |          |
     
     Each layer will therefore implement a /service/ (through its own internal-layer actions), which in
     turn rely on services provided by layer below.
     
     It helps with _Complex Systems_
     
     - The /explicit structure/ of layers allows identification and relationship of complex system's
       pieces.

     - /Modularization/ eases maintenance and updating of system.

*** Airline Travel 
      
      | ticket (/purchase/) |                  |                  | ticket (/complain/) | *ticket*           |
      | baggage (/check/)   |                  |                  | baggage (/claim/)   | *baggage*          |
      | gates (/load/)      |                  |                  | gates (/unload/)    | *gate*             |
      | runway (/takeoff/)  |                  |                  | runway (/land/)     | *takeoff/landing*  |
      | airplane routing  | airplane routing | airplane routing | airplane routing  | *airplane routing* |
      |                   |                  |                  |                   |                  |
           departure  ------>  air-traffic control centers  ------>  arrival
	  
* ISO/OSI
  Since there are /n users of the computer networks scattered throughout the world,
  the /International Organisation of Standardization/ (ISO) has developed a standard for how 
  systems are to communicate. This standard is called an /Open System Interconnection/ (OSI) and can
  be referred to as the *ISO/OSI Reference Model*.
** _ISO/OSI Reference Model_
       
     | Level  | Number | Layer Name   | Description                                                                                                  |
     |--------+--------+--------------+--------------------------------------------------------------------------------------------------------------|
     | _Upper_  |      7 | Application  | Supporting network applications.                                                                             |
     | "      |      6 | Presentation | How data is to be represented in various signals for transmission.                                           |
     | "      |      5 | Session      | Mainly responsible for checkpointing and recovery. Also handles authorization and authentication.            |
     | _Middle_ |      4 | Transport    | Provides the logical communication between application processes running on different hosts.                 |
     | "      |      3 | Network      | Routing of packets/datagrams from source to destination.                                                     |
     | _Lower_  |      2 | Data Link    | Handles vice-versa bit-by-bit conversion between data streams and signals to be used by underlying hardware. |
     | "      |      1 | Physical     | Defines how raw-bits are to be transported over a medium.                                                    |
       
** _Internet Protocol Stack and TCP/IP Suite_
      The /Internet Protocol Stack/ is a conceptual model and set of communication protocols used to 
      satisfy the ISO/OSI reference model for internet communication (as well as many other 
      computer networks).
     

      | Layer Name  | Associated Protocols                                                                                   |
      |-------------+--------------------------------------------------------------------------------------------------------|
      | Application | File Transfer Protocol (FTP), Simple Mail Transfer Protocol (SMTP), HyperText Transfer Protocol (HTTP) |
      | Transport   | Transmission Control Protocol (TCP), User Datagram Protocol (UDP)                                      |
      | Network     | Internet Protocol (IP), /various routing protocols/                                                      |
      | Data Link   | Ethernet, 802.11                                                                                       |
      | Physical    | "on the wire" bit transfer                                                                   |

      _There are 2 layers missing?_
      Both the /presentation layer/ and the /session layer/, if required, must be implemented by within the
      application itself.
      
** _ISO/OSI Diagram_ 

[[file:Introduction/2020-05-09_11-55-09_screenshot.png]]
[[https://community.fs.com/blog/tcpip-vs-osi-whats-the-difference-between-the-two-models.html][image reference]]

* Network Structure
** Scale and Scope
*** LAN (Local Area Network)
     A network of interconnected hosts that covers a small geographical region (e.g. a house, a school,
     etc..).
     
*** MAN (Metropolitan Area Network)
     A network of interconnected hosts that covers a geographical region the size of a metropolitan
     area (e.g. Google's new WiFi towers in the Cape Flats).
     
*** WAN (Wide Area Network)
     A network of interconnected hosts that cover an extremely large geographical region (e.g. the 
     internet is a WAN).

** Transmission Mode
*** Unicast
     Message sent by /one/ sender to /one/ receiver.

     *S -> R*

*** Multicast
     Message sent by one sender to a set/list of recipients.
     
     *S* -> *[R_1,R_2,R_3]*
     
*** Anycast
     Message sent by one sender to any one member of a set (usually the node closest to the sender). 
     
     *S* -> *R_1* | *R_2* | *R_3*

*** Broadcast
     Message sent by one sender to everyone.
     
     *S* -> *R_(1..n)*
     
** Regions
*** Network Edge
     /Hosts/ dwell here. Generally categorized as /clients/ and /servers/.
     
*** Access Networks / Physical Media
     Wired and wireless communication links, commonly managed by /Internet Service Providers/ (ISPs).

*** Network Core
     Interconnected routers producing a network of networks (the internet).
     
**** Packet Switching
      A message is broken up into many different packets which are sent independently down their 
      individual optimum network paths, being forwarded from router to router until they reach their
      destination.
      
***** Packets
       
       * *Header* - contains addresses and other data required for the packet to reach its destination.

       * *Payload* - actual data being sent.

**** Routing 
      Determines the route from source to destination taken by the packet.
      
**** Forwarding
      Directs packet from router's input to appropriate router output.

** Network of Networks
    Important to note that the evolution of the /network of network/ that composes the internet is driven
    by *economic* and *national policies* (obviously, that's why ISPs suck).
    
    Do to the sheer number of potential users of the internet, it is downright impossible to connect
    every individual network together. For this reason, *access ISPs* (Internet Service Providers) have
    been established as administrators and connection hubs for large clusters of networks.

    When pondering how in turn these (millions of) ISPs should communicate with each other, we come
    across a few options.

    1. _Connect each access ISP to every other access ISP?_
       
    This scales horribly - O(N^2) connections!
    
    2. _Connect each access ISP to a global transit ISP (a central hub)?_
    
    This seems viable but who will control this? If it looks good competitors will join the game.
       
    3. _Hierarchical ISP Structure_ (winner)
       
*** Current Topology
     
     
     _Pre-Defs_
     
     * *Peering* - neither party pays for the other in exchange of traffic, they rather gain
       revenue from their own customers.
       
     * *IP Transit* - money is exchanged between parties that agree to peer with one another.

     _Baseline_

     | Tier | Description                                                                                                         | Peering Policy                                                                                 | Examples                                             |
     |------+---------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------+------------------------------------------------------|
     |    1 | Exchange traffic with other /Tier 1 providers/                                                                        | /Strict/ peering agreements (mostly Tier 2 ISPs and Content Provider Networks)                   | Hibernia Networks, Cogent Communications             |
     |    2 | Exchanges traffic between the /Tier 1 and Tier 3 providers/                                                           | /Settlement-Free/ peering (neither party pays but rather attains revenue from its own customers) | Vodafone, British Telekom, GTT Communications        |
     |    3 | Purchases internet transit from Tier 2 providers and delivers internet access to end systems (homes, schools, etc.) | /IP Transit/ with Tier 2 providers                                                               | Mweb, Afrihost, Telkom, Neotel, <your-provider-here> |
     
     _ISP Connections_
     
     * *Internet Exchange Point (IXP)* - a point where multiple ISPs interconnect so
     the internet can exist.

     * *Peering Link* - traffic exchange points for multiple ISPs (for /peering/). 
  
     _Extras_

     * *Content Provider Networks* (like Google, Microsoft, etc..) - may have their own external networks
     to allow faster service delivery. These networks can harbour connections to any ISP as well as
     IXPs

     * *Regional ISPs/Nets* (classified as a /WAN/) - Act as hubs for geographically clustered access ISPs
     in order to interface with global ISPs (and Content Provider Networks). Examples including /Openserve/,
     /Frogfoot/, and Neotel/.
      

     [[file:Introduction/2020-05-10_14-16-25_screenshot.png]]
     
    [[https://upload.wikimedia.org/wikipedia/commons/3/36/Internet_Connectivity_Distribution_%26_Core.svg][image reference]]
    
[[file:Introduction/2020-05-10_14-20-07_screenshot.png]]
 
* Principles
** Physical Layer
   Bits converted to signal over a channel/medium.
   
[[file:Principles/2020-05-11_09-25-42_screenshot.png]]

*** Physical Media
  * *Electrical Cables* - Twister pair (Copper cabling). 
  * *Optical Fibre* - multimode (shorter distances) and monomode (long distances) fibre cables.
  * *Wireless*
    - radio frequency signal (access points and clients)
    - laster and microwave (point-to-point links)

*** Network Speeds Table
| Bit rate | Bits per second |
|----------+-----------------|
| 1 Kbps   |            10^3 |
| 1 Mbps   |            10^6 |
| 1 Gbps   |            10^9 |
| 1 Tbps   |           10^12 |
*** Unreliable Services
    It is possible to have an effective computer network without providing reliable packet transmission.
    An /unreliable service/ is one wherein if the delivery fails (bits lost, created or flipped), the user is not 
    informed.

**** Flipped Bits

[[file:Principles/2020-05-11_09-36-36_screenshot.png]]

**** Lost Bits

[[file:Principles/2020-05-11_09-37-08_screenshot.png]]

**** Created Bits

[[file:Principles/2020-05-11_09-37-46_screenshot.png]]

** Datalink Layer
   
*** Framing

   _Pre-Defs_
   * *Frame* - a structured sequence of bits used as the most basic unit of information exchange between
     two directly connected hosts. Normally consists of a bit/data sequence between /two delimiters/.
   * *Framing* - the act of encoding the frames so the receiver can efficiently extract them from the stream
     of bits that it receives from the physical layer i.e. how can the receiver detect frame boundries?
   * *Bit and Character Stuffing* 
       - Inserting non-information characters or bit-patterns into a frame
       in order to indicate its /start/ and /end/  (the frame boundaries) 
       - Maybe the chosen delimiter is actually found a few times within the data sequence and 
       we need to differentiate it from the actual delimiters.
     
**** Bit Stuffing
     Reserves the /01111110 bit/ to indicate frame boundaries.

     |            ORIGINAL FRAME | TRANSMITTED FRAME                                    |
     |---------------------------+------------------------------------------------------|
     | 0001001001001001001000011 | *01111110* 0001001001001001001000011 *01111110*          |
     | 0110111111111111111110010 | *01111110* 011011111 *0* 11111 *0* 11111 *0* 110010 *01111110* |
     |                  01111110 | *01111110* 011111 *0* 10 *01111110*                        |

**** Character Stuffing
     Uses specific ASCII characters (/DLE/, /STX/, /ETX)/ to indicated frame boundaries.

     | Char Sequence | Meaning            |
     |---------------+--------------------|
     | DLE STX       | /Beginning/ of frame |
     | DLE ETX       | /End/ of frame       |

     *NB*: sender adds a /DLE/ character before each transmitted /DLE/ character i.e. DLE characters already
     within the frame boundaries.

     | ORIGINAL FRAME  | TRANSMITTED FRAME                       |
     |-----------------+-----------------------------------------|
     | 1 2 3 4         | *DLE STX* 1 2 3 4 *DLE ETX*                 |
     | 1 2 3 DLE STX 4 | *DLE STX* 1 2 3 *DLE* DLE STX 4 *DLE ETX*     |
     | DLE STX DLE ETX | *DLE STX* *DLE* DLE STX *DLE* DLE ETX *DLE EXT* |

*** Error Detection
    Frames can be corrupted, lost or even unexpectedly gained. Error detection, put in place to curb these
    mishaps, requires some redundant information in the transmitted frames.

    1. Sender converts each string of /N bits/ into a string of /N+r bits./
       
    2. At receiver, error detection code computes the /r/ redundant bits corresponding to each string of /N bits/
       thus authenticating the bit string.

**** Parity Check Example
     An extremely simple technique of error detection is /parity checking/. An additional bit dubbed the 
     /parity bit/ is added on as the most significant bit (MSB: all the way on the left). The value of the
     parity bit is 1 if the count of 1's (including the parity bit) of a bit sequence is even, with a value 
     of 0 if it's odd.
     
     | Bit String | Parity | Resultant Bit String |
     |------------+--------+----------------------|
     |        000 | Odd    |                 0000 |
     |        001 | Even   |                 1001 |
     |        010 | Even   |                 1010 |
     |        100 | Even   |                 1100 |
     |        111 | Even   |                 1111 |
     |        110 | Odd    |                 0110 |
     |        101 | Odd    |                 0101 |
     |        011 | Odd    |                 0011 |

*** Error Correction
  Error correction can also be done with redundant bits, however, to be able to correct for *n* errors, 
  sender must add *2n* redundant bits per data bit.  

  | Received Bits | Decoded Bit |
  |---------------+-------------|
  |           000 |           0 |
  |           001 |           0 |
  |           010 |           0 |
  |           100 |           0 |
  |           111 |           1 |
  |           110 |           1 |
  |           101 |           1 |
  |           011 |           1 |
  
  Now even if a bit flips, we'll still get a correct output. This seems to scale horribly though.
  
*** Dealing with Errors
    Reliable use error detection rather than error correction (it's a lot less resource taxing). In order
    to detect errors, a frame is divided into two parts.
    
**** Frame Structure
     
     * *Header* - contains fields used by reliable protocols to ensure reliable delivery (e.g. checksum, 
     total frame length).

     * *Payload* - contains the user data.

**** Ideal System
    Idealy all transmitted data units are correctly received.

[[file:Principles/2020-05-11_11-20-13_screenshot.png]]

**** Current System
     We use /control frames/ to stipulate whether the data was successfully transferred or not.

    _Pre-Defs_
    * *Data Frame* - carry /SDU/'s (Service Data Unit - the application data) 
    * *Control Frame* - transfer acknowledgments
      
     [[file:Principles/2020-05-11_11-23-30_screenshot.png]]
 
     The Frame transfer follows a _stop-and-wait_ protocol.

***** _Stop-and-Wait Protocol_

      After sending a /dataframe/, the sender waits for a specified amount of time (/retransmission timer/)
      for a /control frame/ response.

      In a case that the retransmission timer has expired with the sender not receiving a control frame
      response, the packet is retransmitted.

***** _Alternating Bit Protocol_

Instead of passively waiting for the /control frame/ response, the sender repetetively sends the same data
until a response is received (effective, but resource intensive).
    
1. A /data frame/, containing the SDU and an sequence-number (0 at start), is resent continuously 
by the sender until
it receives a /control frame/ from the receiver containing the same sequence-number. When the sender
receives this
response message, it flips the current sequence-number (i.e. 0 -> 1 or 1 -> 0) and starts with 
the next /data frame/.

2. When a receiver receives the uncorrupted /data frame/, it starts sending by /control frame/ 
acknowledgements containing the same index. The receiver will continue to continuously send these
messages until it receives a new /data frame/ with the flipped index (if its sending a control frame
with a index 0, it will wait till it receives a /dataframe/ with an index of 1 and vice-versa).

[[file:Principles/2020-05-11_12-36-07_screenshot.png]]

*** Pipelining
   Sender transmits several consecutive frames having to wait for an acknowledgement after each frame. 
   
   Each of these frames containing a sequence number.

[[file:Principles/2020-05-11_13-22-35_screenshot.png]]

**** Sliding Window
     A set of consecutive sequence-numbers that the sender can use when transmitting frames without
     being force to wait for an acknowledgement. Transmissions and responses are often grouped 
     in incremental subsets.

[[file:Principles/2020-05-11_13-27-26_screenshot.png]]

**** Go-Back-N Protocol
     A protocol that detects frame losses and retransmits lost frames whereby the receiver only
     accepts frames that arrive in-sequence according to the sender "Sliding Window" buffer. 
     This is constrained by the receiver only sending back
     acknowledgements containing the sequence-number of the last in-sequence frame received.
    
[[file:Principles/2020-05-11_13-32-45_screenshot.png]]

This infers *cumulative* acknowledgement since the sequence number returned by the receiver implicitly
acknowledges the receipt of all frames holding a number prior to it.

The sender will retransmit all /unacknowledged frames/ when it has detected a loss (the retransmission
timer expiring).

**** Selective Repeat Protocol
    Similiar to /Go-Back-N/ though now both the receiver and the sender have "Sliding Window" buffers.
    The sender will retransmit only the frames that have been lost.


[[file:Principles/2020-05-11_13-41-59_screenshot.png]]


[[file:Principles/2020-05-11_13-40-42_screenshot.png]]

* Application Layer
  _Accommodates For_
  1) Transport-layer service models
  2) Client-Server
  3) Peer-to-Peer

** Internet as a Service
*** Online Infrastructure
    Provides various services to applications allowing them to utilize things like VoIP, email, 
    e-commerce and accessing the web.

*** Interface Hooks
    
    * *Hook* - a hook is a programming concept that allows modifying the original behaviour of a program
      without changing the code of the corresponding class. Most operating systems rely heavily on hooks
      (I'm looking at you Windows).

    Provides various hooks allowing for applications to send and receive data,
    i.e. /connect/ to the Internet 

** Network Applications
   Online applications that can be utilized by users through web browsers (with the server communicating
   with the web browser software).

   Important to note that *network-core* devices do not run user applications and therefore do not need
   software written for them.

*** Client-Server Architecture
    Communication takes place between *clients* and *servers* exclusively.

    * *Servers* - /always-on/ hosts with /static (permanent) IP/ addresses and an ability to power scale
      through /data centers/.
     
    * *Clients* - /communicate/ with the server but have to always be connected. Clients *normally* have 
      /dynamic IP/ addresses and (in this architecture) do not communicate directly with one another.

*** P2P Architecture
    End systems directly communicate with one-another.
    
    * Peers /request/ services from other peers and /provide/ services in return.

    * Peers, like clients, are intermittently connect and have dynamic IP addresses.

    * *Self Scalability* - new peers bring new service capacity as well as new service demands.

** Services
   Capabilities provided by a system to its users.
   
[[file:Application_Layer/2020-05-11_16-46-26_screenshot.png]]

*** Application Identification
     * *Host IP Address (IPv4 and IPv6)* 
     * *Protocol*
     * *Port Number*

[[file:Application_Layer/2020-05-11_16-54-30_screenshot.png]]

*** Service Primitives
     User and service provider interact using /types of primitives/ (through a /service access point/).
     
     * *REQUEST (from A)* - invokes service and passes any required parameters.
     * *INDICATION (to B)* - advises activation of a requested service.
     * *RESPONSE (from B)* - acknowledges or completes the action invoked by an /indication/ primitive.
     * *CONFIRM (to A)* - acknowledges or completes an action invoked by a /request/ primitive.

*** Transport Service
    Allows networked applications to exchange messages.
    
[[file:Application_Layer/2020-05-11_17-00-28_screenshot.png]]

**** Connectionless Service
    A data communication between two nodes where the sender sends data without ensuring whether the
    receiver is available to receive the data. There is also no notification of a failure, and no
    assumptions can be made to the success of the delivery.
    
    _Primitives_
    + REQUEST
    + INDICATION
      

[[file:Application_Layer/2020-05-11_17-48-29_screenshot.png]]

***** _Problems_
     Since there are no acknowledgment messages, none of these errors would be apparent. 
      * Frames being lost.
      * Frames duplicated in transmission.
      * Frames transmitted with corrupted messages.
      * Frames arriving in an inrcorrect order.

**** Connections-Orientated Service
     A data communication between two nodes whereby before the entities communicate, a dedicated
     connection between them is established.

     _Primitives_
     + REQUEST
     + INDICATION
     + RESPONSE
     + CONFIRM

***** _Message-Mode Transfer_

[[file:Application_Layer/2020-05-11_18-04-26_screenshot.png]]

***** _Stream-Mode Transfer_
      
[[file:Application_Layer/2020-05-11_18-07-17_screenshot.png]]
 
**** Connections-Orientated vs. Connectionless Table of Comparison
     
| _Connections-Orientated_                   | _Connectionless_           |
|------------------------------------------+--------------------------|
| reliable transport                       | unreliable data transfer |
| flow control                             | no flow control          |
| congestion control                       | no congestion control    |
| requires setup between client and server | no setup required        |
| no timing                                | no timing                |
| no throughput guarantee                  | no throughput guarantee  |
| no security                              | no security              |

** Process Communication

   _Pre-Defs_
   * *Process* - program running within a host
   * *Client Process* - process that initiates communication
   * *Server Process* - process that waits to be contacted
   * *Socket* - point at which processes /send/ and /receive/ messages
     
   Within the *same host*, two processes communicate using /inter-process communication/ (defined by the
   OS).

   Processes in *different hosts* communicate by exchanging /messages/.

   It's important to note that applications with /P2P/ architectures also have *client processes* and
   *server processes*.
   
*** Address Processing
    While each host has it's own unique 32-bit IP address, multiple processes can be run on the same
    host, meaning the IP is not sufficient to address a particular process. For this reason, 
    processes have *identifiers.*

   * *Identifier* - includes both /IP Address/ and /Port Numbers/ associated with a process 
    

*** Socket Programming
    Allow various client/server processes to communicate over a network.

[[file:Application_Layer/2020-05-11_19-28-36_screenshot.png]]

_Socket Types_
 * *UDP* - unreliable datagram (connectionless)
 * *TCP* - reliable, byte stream-oriented (connection-orientated)

**** TCP Socket Programming
     TCP provides reliable, in-order byte-stream transfer between client and server.

    1. *client* must /contact/ server 
      - server process must be running
      - server must have created *socket*

    The client goes about this by creating a /TCP/ socket, specifying *IP Address* and *Port Number*
    of server process. When the socket is created, client TCP establishes connection to server
    TCP.

    2. when contacted by the client, the *server* /creates a new socket/ for the server process to 
       communicate with that client.
      - this allows the server to talk to multiple clients 
      - *source port numbers* are used to distinguish between clients

[[file:Application_Layer/2020-05-11_19-42-33_screenshot.png]]

***** _Input/Output Streams_
      
      * *Stream* - a sequence of characters that flow into or out of a process

      * *Input Stream* - attached to an input source for the process (e.g. keyboard, socket)

      * *Output Stream* - attached to an output source (e.g. monitor, socket)

[[file:Application_Layer/2020-05-11_19-50-26_screenshot.png]]
** Web
   A *web page* consists of *objects*.
   
   *Objects* can be /HTML files/, /JPEG images/, /Java applets/, /audio files/, etc..

   Web pages consist of a /base HTML-file/ which includes several referenced objects.

   Each object is addressable by a *URL (Universal Resource Locator)*

*** Internet Application Protocol Table
 
| APPLICATION            | LAYER PROTOCOL |
|------------------------+----------------|
| e-mail                 | SMTP           |
| remote terminal access | Telnet         |
| web                    | HTTP           |
| file transfer          | FTP            |
| streaming multimedia   | HTTP, RTP      |
| internet telephony     | SIP, RTP, VoiP |
** HTTP (HyperText Transfer Protocol)
  The Webs *application layer protocol* (which is HTTP). HTTP is 'stateless' meaning the server maintains
  no information about past client requests.

  * *client role* - browser that requests, receives, and displays Web objects (using HTTP)
  * *server role* - web server sends objects in response to requests (using HTTP)

*** TCP Usage
    1. *Client* initiates TCP connection (creates socket) to server, port /80/.
    2. *Server* accepts TCP connection from client.
    3. HTTP messages exchanged between *browser* (HTTP client) and *web server* (HTTP server).
    4. TCP connection closed.

*** HTTP Connections

**** Non-Persistent HTTP
     The connection is closed after the server sends the requested object to the client.

     _Example_
     Suppose a user enters the URL:
     www.someuni.ac.za/someDepartment/home.index
     
     1. HTTP *client* initiates TCP connection to HTTP server (process) at www.someuni.ac.za on port 80.
     2. HTTP *server* at host www.someuni.ac.za waiting for TCP connection at port 80. Accepts connection,
	notifying client.
     3. HTTP *client* sneds HTTP /request message/ (containing URL) into TCP connection socket. Message
	indicates that client wants some object "someDepartment/home.index"
     4. HTTP *server* receives request message, forms /response message/ containing requested object, and
	sends message into its socket.
     5. HTTP *server* closes TCP connection
     6. HTTP *client* receives response message containing html file, displays html. Parsing html file,
	finds 10 referenced jpeg objects.
     7. Steps 1 - 6 repeated for each of 10 jpeg objects.
	
***** _Response Time_
      
      * *RTT (Round-Trip-Time)* - time for a small packet to travel from client to server and back.
     
      |   | One RTT to initiate TCP connection                                      |
      | + | One RTT for HTTP request and first few bytes of HTTP response to return |
      | + | File transmission time                                                  |
      | = | 2RTT + file transmission time                                           |
      | = | non-persisten HTTP response time                                        |
**** Persistent HTTP
     The connect remains open after the server sends a response. Subsequent HTTP messages between the
     same server and client are sent over the open connection. The client sends requests as soon as it
     encounters a referenced object. As little as /one RTT/ for all the referenced objects.
*** HTTP Messages
**** HTTP Request Message

GET /index.html HTTP/1.1\r\n
Host: www-net.cs.umass.edu\r\n
User-Agent: Firefox/3.6.10\r\n
Accept: text/html,application/xhtml+xml\r\n
Accept-Language: en-us,en;q=0.5\r\n
Accept-Encoding: gzip,deflate\r\n
Accept-Charset: ISO-8859-1,utf-8;q=0.7\r\n
Keep-Alive: 115\r\n
Connection: keep-alive\r\n
\r\n
**** HTTP Response Message

HTTP/1.1 200 OK\r\n
Date: Sun, 26 Sep 2010 20:09:20 GMT\r\n
Server: Apache/2.0.52 (CentOS)\r\n
Last-Modified: Tue, 30 Oct 2007 17:00:02
GMT\r\n
ETag: "17dc6-a5c-bf716880"\r\n
Accept-Ranges: bytes\r\n
Content-Length: 2652\r\n
Keep-Alive: timeout=10, max=100\r\n
Connection: Keep-Alive\r\n
Content-Type: text/html;
charset=ISO-8859-1\r\n
\r\n
data data data data data ...
**** HTTP Response Status Codes
     The status code appears in the /1st line/ of a *server-to-client* response message.
     
     | Status Code | Title                      | Description                               |
     |-------------+----------------------------+-------------------------------------------|
     |         200 | OK                         | request succeeded                         |
     |         301 | Moved Permanently          | requested object moved                    |
     |         400 | Bad Request                | request message not understood            |
     |         404 | Not Found                  | request document not found on this server |
     |         505 | HTTP Version Not Supported | <self-explanatory>                        |
*** Cookies
    Stored locally on a users computer, an HTTP cookie stores stateful information ranging from things
    such as what's in the users shopping cart, what has been entered into input fields, what the user's
    browsing activity contains, amongst many other things.

    A browser will send a cookie in all requests to the server, most often used for server
    authentication.

**** Cookie's Components
     
     1. Cookie header line of *HTTP response message*
     2. Cookie header line in next *HTTP request message*
     3. Cookie file kept on *user's host*, managed by user's browser
     4. Back-end *database* at Web site
*** Web Caches
   Able to satisfy a clients request without involving the origin server. 

   Generally a web browser sends all HTTP requests to the cache.

   * If the object is in the cache: returns object
   * Else: request object from origin server, then returns object

** DNS (Domain Name System)
   A /distributed database/ implemented in a hierarchy of many *name servers*. Hosts communicate with the
   name servers recursively in order to resolve names (translate a URL into an IP Address).
*** DNS Services
    * *Translation* - URL to IP Address
    * *Host Aliasing* - Alias Name vs Canonical Name (CNAME)
    * *Mail Server Aliasing* - Pretty much email forwarding
    * *Load Distribution* - many IP addresses can correspond to one name
*** DNS Hierarchical Database Structure
    
[[file:Application_Layer/2020-05-11_21-23-51_screenshot.png]]
*** Root Name Servers
    Servers at the root of the DNS hierarchy. Usually contacted by local name servers that can not
    resolve a name.
    
    1. Contacts authoritative name server if name mapping not known.
    2. Gets mapping.
    3. Returns mapping to local name server.

[[file:Application_Layer/2020-05-11_21-27-25_screenshot.png]]
*** Authoritative Servers
    
**** Top-Level Domain Servers
     Responsible for *com*, *org*, *net*, *edu*, *aero*, *jobs*, *museums*, and all top-level country domains, 
     e.g. *uk*, *ao*, *mw*, *gh*, *za*

**** Authoritative DNS Servers
     Organization's *own* DNS servers, providing authoritative hostname to IP mappings for organization's
     named hosts. Either maintained by the organization or a service provider.
*** Local DNS Name Server (Default Name Server)
    Does not strictly belong to the DNS hierarchy. Usually each ISP (including companies, universities,
    etc..) has one.
    
    When a host makes a DNS query, the query is sent to its local DNS server, which also contains a
    cache of recent name-to-address translation pairs (potentially outdated).
*** DNS Query Types
**** Iterative Query

[[file:Application_Layer/2020-05-11_21-37-48_screenshot.png]]

**** Recursive Query

[[file:Application_Layer/2020-05-11_21-38-33_screenshot.png]]
 
*** DNS Records
    
    * *Resource Records (RR) Format* - (/name/, /value/, /type/, /ttl/) 
      
**** DNS Type Table
| TYPE  | name                                 | value                                                 |
|-------+--------------------------------------+-------------------------------------------------------|
| A     | hostname (www.foo.com)               | IP address                                            |
| NS    | domain (foo.com)                     | hostname of authoritative name server for this domain |
| CNAME | alias name for some 'canonical' name | actual canonical name                                 |
| MX    | hostname                             | mailserver associated with name                       |
*** DNS Message Format

[[file:Application_Layer/2020-05-11_21-50-39_screenshot.png]]

* Transport Layer
  Logical communication betweeen *hosts*.

** Transport Services and Protocols
    Provides /logical communication/ between processes running on different hosts.
    
    These transport protocols run in *end systems*.
    
| *SENDER SIDE*   | breaks application messages into /segments/ and passes them to the /network layer/. |
| *RECEIVER SIDE* | reassembles segments into messages and passes them to the /application layer/.    |
** Internet Transport-Layer Protocols
    
    | TCP                | UDP                 |
    |--------------------+---------------------|
    | Reliable Delivery  | Unreliable Delivery |
    | In-Order Delivery  | Unordered Delivery  |
    | Congestion Control |                     |
    | Flow Control       |                     |
    | Connection Setup   |                     |
** Multiplexing/Demultiplexing

    * *Multiplexing at Sender* - handles data from /multiple sockets/ as well as adding a /transport header./

    * *Demultiplexing at Receiver* - uses /transport header/ info to /deliver/ received segments to correct
      /sockets/.

[[file:Transport_Layer/2020-05-12_09-21-11_screenshot.png]]

**** Connection-Orientated Demultiplexing
     Server hosts /many simultaneous/ TCP sockets, each socket idenitified by its own 4-tuple (a piece
     of information containing four parts). Web servers have different sockets for each request.
     
     1. *Host* receives /IP datagrams/.

	_TCP Datagram Makeup_
	+ Source IP Address
	+ Destination IP Address
	+ 1 Transport-Layer Segment
	  
	_Segment Makeup_
	+ Source Port Number
	+ Destination Port Number
	+ Application Data
	
     2. *Host* uses the *source IP Address*, *source Port Number*, *destination IP Address* 
     and *destination Port Number* to /direct segments/ to approriate sockets. 
     
***** _Connection-Orientated Demultiplexing Example_  
      
[[file:Transport_Layer/2020-05-12_10-04-03_screenshot.png]]
 

**** _Connectionless Demultiplexing_
      
     1. *Host* receives /IP datagram/.

        _UDP Datagram Makeup_
	+ Destination IP Address
	+ Destination Port Number
	  
	_Segment Makeup_
	+ Source Port Number
	+ Destination Port Number
	+ Application Data
	  
     2. *Host* receives UDP segment, it checks for the port number and then directs the UDP segment
	to a socket with that port number.
	
     *NB:* all UDP datagrams with /same destination port/ but different /IP Addresses/ and/or /Source Port Numbers/
     will be directed to the *same socket* at destination.

***** _Connectionless Demultiplexing Example_

[[file:Transport_Layer/2020-05-12_10-00-56_screenshot.png]]
** Principles of Reliable Data Transfer (RDT)
    The /transport layer/ interacts with /application/ and /network layers/. It's this connection channel
    operates that will determine the complexity of *reliable data transfer*.

[[file:Transport_Layer/2020-05-12_10-11-03_screenshot.png]]

*Writers Note*: 85% of what else is explained in these slides has been already explained in the data-link
section. Perhaps some day I will move some of those sections here and add more when I have the time. 

_Already Covered In Datalink List_
+ *Stop-and-Wait* 
+ *Stop-and-Wait + Sequence Numbers*
+ *Pipelining*
+ *Go-Back-N*
+ *Selective Repeat*

** Principles of Congestion Control
   
   _Pre-Defs_
   * *Throughput* - The rate at which data is traversing a connection.
   * *Goodput* - The rate at which /useful/ data is traversing a connection.
   * *Congestion* - too many sources sending too much data too fast for the /network/ to handle.
     /Throughput/ suffers due to extreme input.
     
*** Causes of Congestion Control
**** Scenario 1
     
     - Two Senders, Two Receivers
     - One Router, /infinite/ buffers
     - Output Link Capacity: R
     - no retransmission
       
***** _Network Diagram_

[[file:Transport_Layer/2020-05-12_15-32-39_screenshot.png]]


***** _Maximum Per-Connection Throughput_

[[file:Transport_Layer/2020-05-12_15-33-33_screenshot.png]]
 

***** _Delays_
      
[[file:Transport_Layer/2020-05-12_15-34-28_screenshot.png]]
 
**** Scenario 2
    
     - Two Senders, Two Receivers
     - One Router, /finite/ buffers
     - Output Link Capacity: R
     - yes retransmission
   
   Packets can be lost, dropped at router due to full buffers, if the *sender* times out
   prematurely on a packet stuck in the buffer, it will eventually retransmit a copy, 
   both of which eventually delivered resulting in unneeded retransmissions (decreases 
   /goodput)/.

*** Results of Congestion
    * *lost packets* - buffer overflow at routers
    * *long delays* - queuing in router buffers

*** Approaches to Congestion Control
**** End-End Congestion Control
     Congestion is inferred from end-system observed loss or delay, with no explicit
     feedback from the network.
**** Network-Assisted Congestion Control
     Routers provide feedback to end systems using a single bit to indicate congestion,
     offering an explicit rate for the sender to send at.
** TCP Revisited
*** TCP Segment Structure

[[file:Transport_Layer/2020-05-12_14-28-11_screenshot.png]]

*** Sequence Numbers and ACKS

     * *Sequence Numbers* - byte stream index of specific segment

     * *Acknowledgements (ACK)* - a control frame approval response containing the last
       successfully transferred segment.
       
*** TCP Connection Management
    Establishing a consistent,secure connection.
**** Two-Way Handshake
     Similar issues to UDTs plague two-way handshakes.

[[file:Transport_Layer/2020-05-12_14-42-04_screenshot.png]]

**** Three-Way Handshake
     
     1. _SYN_ : *Client* sends a /SYN/ (Synchronize Sequence Number) which informas the *server* that the
	*client* wants to establish a connection and with what sequence number it starts
	segmenting with.

     2. _SYN + ACK_ : *Server* responds to the *client* request with /SYN-ACK/. The /ACK/ signifies the
	response of segment it received and the /SYN/ signifies with what /sequence number/ it is
	likely to start the segment with.
	
     3. _ACK_ : The *client* responds with an /ACK/ acknowledging the server response and they
	both establish a reliable connection.
     
***** _Three-Way Handshake Diagram_
[[file:Transport_Layer/2020-05-12_14-51-55_screenshot.png]]
 
**** Closing a Connection
     Both the *client* and *server* have to close their side of the connection by sending a
     /FIN/. A /FIN/ is responded to with an /ACK/ which can be combined with a /FIN/. Multiple /FIN/
     exchanges can be handled.
***** _Closing Connection Diagram_
[[file:Transport_Layer/2020-05-12_14-55-06_screenshot.png]]
 
*** TCP Timeout
    A TCP *timeout* is the amount of time before the *sender* retransmits a segment.
    
    * *Round Trip Time (RTT)* - time taken between sending a message to a destination and
      recieving a response.

    * *SampleRTT* - measured time from segment transmission until ACK receipt (we should
      however average many of these readings to find an accurate /RTT/.

**** Setting a TCP Retransmission Timeout
     Longer than /RTT/ (but /RTT/ varies).

     /Premature/ timeouts lead to unnecessary retransmissions.
     /Slow timeouts/ 

***** _Estimating the RTT_
      EstimatedRTT = (1 - α)*EstimatedRTT + α*SampleRTT
      (typical value for weight α is 0.125)
     

[[file:Transport_Layer/2020-05-12_15-08-41_screenshot.png]]
*** TCP Flow Control
    *Receiver* controls *sender* so the *sender* won't overflow the *receiver's* buffer by
    transmitting too much, too fast.
    
    * *RcvBuffer* - buffer between the TCP socket and the application process and has a size
      set via socket options (typical default is 4096 bytes)
    
    * *Receiver Window (rwnd)* - a TCP variable that advertises amount of free space within 
      destination RcvBuffer.

**** TCP Receiver Buffer (RcvBuffer)
     The *receiver* advertises free *RcvBuffer* space by including an *rwnd* value in the /TCP header/
     of the receiver-to-sender segments.
     
     The *sender* then limits amount of unacked data to receiver's *rwnd* value which guarantees
     the *RcvBuffer* will not overflow.
*** TCP Congestion Control
    
    * *Congestion Window (cwnd)* - a /TCP/ state variable that limits the amount of data the TCP
      can send in the network before receiving an /ACK./

    * *Maximum Segment Size (MSS)* - the maximum amount of data, in bytes, held by a single
      /TCP segment./

**** Additive Increase & Multiplicative Decrease
     *Sender* increases transmission rate (*cwnd*), probing for usable bandwidth until
     loss occurs

     * *Additivte Increase* - increase *cwnd* by /1 MSS/ every RTT until loss detected
     * *Multiplicative Decrease* - cut *cwnd* in half after loss detected
       
[[file:Transport_Layer/2020-05-12_16-10-12_screenshot.png]]


**** Slow Start
    When connection begins, increase rate exponentially until first loss event 

    1. initially *cwnd* = /1 MSS/
    2. double *cwnd* every RTT
    3. Done by incrementing *cwnd* for every /ACK/ received
* Network Layer
  Transports segment from sending host to receiving host.
  
  * *Sending side* - encapsulates /segments/ into datagrams (packets)
     
  * *Receiving side* - delivers segments to transport layer

  There are network layer protocols present in *every* /host/ and /router/.

  A *router* examines header fields in all /IP datagrams/ passing through it.

  _Pre-Defs_
  * *routing table* - defines what to do with incoming /packets/, often through a routing table
    that contains a list of destination addresses and the outgoing interfaces associated with 
    them

** Key Network-Layer Principles
   * *Addressing* - each network layer entity is identified by a network layer address
   * *LinkLayer Independence* - service provided does not depend on internal organisation of
     the underlying datalink layers
     
*** Two Planes
**** Control Plane (network-wide logic)
     Part of /router architecture/ that is concerned
      with drawing the /network topology/ by computing and installing /routing tables/.

**** Data Plane (local, per-router)
     Used by *hosts and routers* to /create and process (packet-switching)/ the packets that
     contain data.

*** Two Key Functions
**** Routing
     Determine /route/ taken by packets from source to destination (through routing
     algortihms).
**** Forwarding
     Move packets from router's input to appropriate router output.
*** Interplay between Routing and Forwarding
    
    * Routing algorithm (routing table) determines *end-to-end-path* through the /network/.

    * Forwarding table determines *local forwarding* in the local router.
** Internet Network Layer
*** Protocol Diagram 
[[file:Network_Layer/2020-05-12_18-05-31_screenshot.png]]

*** IP Datagram Format
[[file:Network_Layer/2020-05-12_18-09-58_screenshot.png]]
 
*** IP Fragmentation and Reassembly
    _Pre-Defs_
    * *MTU* - maximum transfer size (largest possible link-level frame). Different link types have different MTUs.  
     
   IP header bits used to /identify and order/ related fragments.
**** Fragmentation
     *Large IP datagrams* are /fragmented/ within networks whereby /one datagram/ becomes /several datagrams/.
     
**** Reassembly
     *Fragmented IP datagrams* are reassembled only at /final destination/.
*** IP Addressing
    * *IP Address* - 32bit identifier for /hosts/, /router interface/
    * *Interface* - connection between /host/router/ and /physical link/
      
     *IP Addresses* are associated with *each interface*
     
    [[file:Network_Layer/2020-05-12_18-54-02_screenshot.png]]
 
** Network Layer Service Models
  
   * *Datagram Network* - provides network-layer /connectionless/ service
   * *Virtual-Circuit Network* - provides network-layer /connection/ service

*** Service Model vs. TCP/UDP Differences
    * *services*: host-to-host
    * *no choice*: networks provides one or the other
    * *implementation*: in network core 
*** Datagram Networks
    /No required setup/ at network layer. Packet contains *source* and *destination* host address, and *data*.
    
    *Routers* don't have a state about /end-to-end/ connections (hop-by-hop forwarding). Packets are forwarded using
    /destination host address/ (through referencing the *forwarding table*).

**** Datagram Forwarding Table

[[file:Network_Layer/2020-05-12_18-55-38_screenshot.png]]
 
***** _Longest Prefix Matching_
      When looking for forwarding table entry for given destination address, use *longest* address
      prefix that matches destination address.
      
*** Subnets
    A *logical subdivision* of an IP network. Devices interface with same /subnet/ part of *IP Address*.
    Can physically reach each other /without intervening router/.

**** Subnet IP Address
     * *subnet part* - high order bits
     * *host part* - low order bits

**** Subnet Diagram
[[file:Network_Layer/2020-05-12_19-32-52_screenshot.png]]

**** Classless InterDomain Routing (CIDR)
     *Subnet portion of address* of arbitrary length.

     _Address Format_
     *a.b.c.d/x* where *x* is number of bits in subnet portion of address.

[[file:Network_Layer/2020-05-12_19-38-03_screenshot.png]]

***** _CIDR Example_
      Suppose packets with the *destination IP address 137.145.128.128* arrives
      at the router *R*. What will the outgoing link interface be for forwarding these packets?

      | Destination Network | Outgoing Link Interface |
      |---------------------+-------------------------|
      | 137.158.16.0/20     |                       1 |
      | 137.156.0.0/14      |                       2 |
      | 136.0.0.0/6         |                       3 |
      | 128.0.0.0/1         |                       4 |

      _Answer_

1) Write out the binary prefix
      
| Destination Network | Outgoing Link Interface |          Binary Prefix |
|---------------------+-------------------------+------------------------|
| 137.158.16.0/20     |                       1 | 10001001.10011110.0001 |
| 137.156.0.0/14      |                       2 |        10001001.100111 |
| 136.0.0.0/6         |                       3 |                 100010 |
| 128.0.0.0/1         |                       4 |                      1 |

2) Write out the destination address in binary

| Destination Address | Binary Address (matching prefix underline) | Outgoing Link Interface |
|---------------------+--------------------------------------------+-------------------------|
|     137.145.128.128 |        10001001.10010001.10000000.10000000 |                       3 |

3) Check longest prefix matching
**** Hierarchical Addressing
     Hierarchical addressing allows efficient advertisement of routing information. Some routes
     more direct than others (largely dependent on ISP).
     
***** _Hierarchical Diagram_
[[file:Network_Layer/2020-05-12_19-58-24_screenshot.png]]


***** _How ISPs get Addresses_
      
      * *ICANN* - Internet Corporation for Assigned Names and Numbers
**** Network Address Translation (NAT)
     Router technology that allows translation between /private/ and /public/ IP Addresses 
     created to address the shortage of IPv4 address possibilities.
     
     Using a 16-bit port number, there can be 60 000 simultaneous connections with a
     single LAN-side address. Can also be solved by IPv6.
     
***** _NAT Diagram_

[[file:Network_Layer/2020-05-12_20-14-53_screenshot.png]]

 

** IPv6
*** Motivation
    32-bit addresses anticipated to be exhausted by 2008.
    
    _Additional Motivation_
    + *header format* helps speed /processing/forwarding/.
    + *header changes* to faciliate /Quality of Service./

*** Datagram Format
  * Fixed-length 40 byte *header*
  * No fragmentation allowed
  * /128 bit/ address space (3.4 x 10^38 addresses)
    
**** IPv6 Diagram
[[file:Network_Layer/2020-05-12_20-27-34_screenshot.png]]
 

**** Other Changes from IPv4
     
     * *checksum* - removed entirely to reduce processing time at
       each hop
     
     * *options* - allowed, but outside of header, indicated by "Next Header" field

     * *ICMPv6* - new version of ICMP, additional message types and multicast group management
       functions
*** Transition from IPv4 to IPv6
    Not all routers can be upgraded simultanously.

    * *tunneling* - IPv6 datagram carried as /payload/ in IPv4 datagram amount IPv4 routers
      
     [[file:Network_Layer/2020-05-12_20-37-35_screenshot.png]]
 
**** Tunneling Diagram

[[file:Network_Layer/2020-05-12_20-39-21_screenshot.png]]
 
** Graph Abstraction
   
   * *key question* - what is the least cost path between /u/ and /z/?

   * *routing algorithm* - algorithm that finds that least cost path

*** Graph Diagram
[[file:Network_Layer/2020-05-12_20-44-02_screenshot.png]]
 
*** Routing Algorithm Classification
**** Global or Decentralized?
     
     * *global* - all routers have complete topology and link cost info (/link state algorithms/)

     * *decentralized* - router knows physically-connected neighbours and link costs to
       neighbours. Iterative process of computation (exchange of info with neightbours)
       (/Distance Vector Algorithms/)

**** Static or Dynamic?
     
     * *static* - routes change slowly over time

     * *dynamic* - routes change more quickly with periodic updates and response to link cost
       changes
*** Link-State Routing Algorithm
**** Dijkstra's Algorithm
     * Net topology and link costs known to all nodes. This is accomplished through
       /link state broadcast/. All nodes have the same info.
     * Computes lest cost paths from one node ("source") to all other nodes. Gives a forwarding
       table for that node.
     * After *k* iterations, we will know the /least cost path/ to *k* destinations.
       
***** _Notation_
      * *c(x,y)* - link cost from node /x/ to /y/ = ∞ if not direct neighbours
      * *D(v)* - current value of cost path from /source/ to /destination/ v
      * *p(v)* - predecessor node along path from /source/ to v
      * *N'* - set of nodes whose least cost path definitely known
**** Bellman-Ford Equation
[[file:Network_Layer/2020-05-12_21-02-21_screenshot.png]]
 
***** _Bellman-Ford Example_
[[file:Network_Layer/2020-05-12_21-04-15_screenshot.png]]
 
**** Distance Vector Algorithm
     From time-to-time, each node sends its own distance vector estimate
     to neighbours

[[file:Network_Layer/2020-05-12_21-06-17_screenshot.png]]
 
*** Hierarchical Routing
    All routers identical. Network is /flat/ (but not really).

    * *Administrative Autonomy* - each network admin is able to control routing in their
      own network

    * *Autonomous Systems* - regions of aggregated routers
      
    * *Gateway Router* - a router at the /edge/ of its own AS
      
    The routers in same *AS* run same /routing protocol/ (intra-AS routing protocol)
**** Reasons
     * *scale* - 600 million destinations

     Can't store all destinations in routing tables. Routing table exchange would
     swamp links.
**** Interconnected ASes
     Forwarding table conffigured by both intra and inter-AS routing algorithm

     * /intra-AS/ sets entries for internal destinations
     * /inter-AS & intra-AS/ sets entries for external destinations

***** _Inter-AS Tasks_
      Suppose router in AS1 receives datagram destined for outside the AS1. Router should
      forward packet to gateway router, but which one?

      *AS1 must* (through /inter-AS routing/)
      1. learn which dests are reachable through *AS2* and which through *AS3*
      2. Propagate this reachability info to all routers in *AS1*

[[file:Network_Layer/2020-05-12_21-26-39_screenshot.png]]

****** _BGP (Border Gateway Protocol)_ 
       The de-factor inter-domain routing protocol (glue that holds the Internet together).
       * *eBGP* - obtain subnet reachability information from neighboring ASs
       * *iBGP* - propagate reachability information to all AS-internal routers
       Determine /good/ routes to other networks based on reachability information and policy.
***** _Intra-AS Routing_
      Also known as *interior gateway protocols (IGP)*.

      _Most Common Protocols_
      + *RIP*: Routing Information Protocol
      + *OSPF*: Open Shortest Path First
      + *IGRP*: Interior Gateway Routing Protocol (Cisco proprietary)

****** _OSPF_ (Open Shortest Path First)
       * Publically available
       * Uses link state algorithm (using Dijkstra's)
       * OSPF advertisement carries one entry per neighbour
       * Advertisements flooded to *entire AS* (carried directly over IP)

****** _Hierarchical OSPF_
       
       * *Two-level Hierarchy* - local area, backbone. Link-state advertisements only in area. Each
	 nodes has detailed area topology, only know directions to nets in other areas

       * *Area Border Routers* - summarize distances to nets in own area, advertise to other Area
	 Border routers

       * *Backbone Routers* - run OSPF routing limited to backbone

       * *Boundary Routers* - connect to other AS's
